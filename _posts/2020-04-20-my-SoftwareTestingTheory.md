---
layout:     post                    # 使用的布局（不需要改）
title:      软件测试基础理论              # 标题
subtitle:   作为想入门测试行业的你，这是必须要了解的理论知识     #副标题
date:       2020-04-20              # 时间
author:     coconut                      # 作者
header-img:    #这篇文章标题背景图片
catalog: true                       # 是否归档
categories: 软件测试
tags:                               #标签
    - 软件测试
---
# 软件测试的分类

[TOC]
## 第一章 计算机基础
### 1、什么是软件
  软件是计算机系统与硬件相互依存的另一部分。它包括程序与文档的完整集合。
  * **程序：**（program）是为实现特定目标或解决特定问题而用计算机语言编写的命令序列的集合。为实现预期目的而进行操作的一系列语句和指令。
  * **文档：**
    - 文档是一种对软件系统的书面描述；
    - 文档应当精确地描述软件系统；
    - 软件文档是软件工程师之间用作沟通交流的一种方式；
    - 文档的类型有很种，包括软件需求文档，设计文档，测试文档，用户手册等；
    - 文档的呈现方式有很种，可以是传统的书面文字形式或图表形式，也可是动态的网页形式。  
### 2、什么是软件缺陷
  怎么判断是否是缺陷？
  * 缺陷的定义一：
  > **五个规则**

  >- 1、软件未实现产品说明书要求的功能；（列如：手机不能发信息）
  >- 2、软件出现了产品指明不应该出现的错误；
  >- 3、软件实现了产品说明书未提到的功能；（画蛇添足）
  >- 4、软件未能实现说明虽未明确提及，但应实现的功能
  >- 5、软件难以理解，不易使用，运行缓慢，或者从测试员的角度看，最终用户会为人不好。
  * 软件缺陷的定义二：
  >- 美国电气和电子工程师协会（IEEE）对缺陷的定义：
  >- 从产品内部看，缺陷是软件产品开发或维护过程中存在的错误和毛病等各种问题。
  >- 从产品外部看，缺陷是系统所需要实现的某种功能的失效或违背。
  >- 简单的说，用户在软件使用的过程中，遇到的任何错误、异常都可以称之为“软件缺陷”
### 3、什么是软件测试
  现有的软件寻找缺陷，软件测试的过程就是寻找缺陷的过程。
  英语：Software Testing），描述一种用来促进鉴定软件的正确性、完整性、安全性和质量的过程。换句话说，软件测试是一种实际输出与预期输出间的审核或者比较过程。软件测试的经典定义是：在规定的条件下对程序进行操作，以发现程序错误，衡量软件质量，并对其是否能满足设计要求进行评估的过程。
### 4、软件测试的历史
  Bug的由来
  一般我们把软件缺陷（Defect）成为bug（臭虫）
  1947年，哈佛大学制造的马克二型（Mark Ⅱ）计算机
  这个项目的领导者是Grace Hopper （格雷斯.哈珀-1906-1992）
  曾经担任过美国海军将军，著名的计算机语言cobol编译器的发明者，计算机业有史以来最杰出女性，Cobol语言设计者，设计第一个编译程序，发现世界上第一个BUG。

  > 测试的对象：文档 
  * ①需求规格说明书
  * ②软件概要设计说明书
  * ③软件详细设计说明书
  * ④用户帮助手册
  * ⑤测试用例
### 5、计算机的层次
![图片](https://hi-yee.github.io/coconut-blog/images/imageSoftwareTestingTheory/ct-01.png)
  
提问：
裸机包含软件吗？
答：裸机也包含软件，主要是BIOS程序（Basic input/output system）=基本输入/输出系统
存在何处：存在主板上的一块cmos芯片中。
开机快速按delete（删除键）键进入BIOS系统（笔记本一般为功能键f4）

（裸机中软件）作用：计算机接通电源后，首先由BIOS程序，BIOS对计算机进行硬件“商店自检”，检查所有硬件是否连接完好，如果连接有问题，通过蜂鸣器发出精神，并停止计算机的启动，如果没有问题，将吧控制权交给操作系统。

常见的计算机操作系统有：
Windows   +   Unix   +   Linux   +   苹果
### 6、软件的分类
  (1)软件基本分类：系统软件+应用软件
   系统软件：包括操作系统、操作系统补丁程序、驱动程序（操作系统的内核程序通过调用硬件的驱动程序完成硬件管理功能）
  
  **操作系统（Operating system，简称OS）的主要功能：**
  - 硬件（设备）管理：通过驱动程序，调度控制硬件设备。
  - 进程管理：对运行的程序进行管理。
  - 存储（内存）管理：下内存可以运行大程序。
  - 文件管理：管理文件和文件夹

   **那些软件属于支持服务工具？**
   - 硬件测试软件
   -（3D Mark 显卡评测）
   - 防病毒程序

  **常见的数据库管理软件有哪些？**
  - SQL server 2008
  - oracle
  - My SQL

   (2)按照软件结果分类（看软件的运行是否基于网络）
   >不是，单机软件

   >是，分布式软件

   - C/S结果（client/server客户端/服务器结构）客户端需要使用专门的软件访问服务（列如：QQ，MSN，需要注册账号）
   - B/S结果（Browser/server浏览器/服务器结构）客户端只需要有浏览器就能访问服务网站。（列如：京东商城论坛，百度等）

   **如何区分C/S结构和B/S结构软件**
   > 主要看客户端需不需要安装专门的软件
   - 需要——C/S结构
   - 不需要——B/S结构

## 第二章 进制转换
### 1、进制转换
  **数制的概念：**
  >数制也称进制，是指用一组固定的符合和统一的规则来表示数值的方法。任何一个数制都包含两个基本要素：基数和位权。

  **数码**
  >数制中表示基本数值大小的不同数字符号。例如，十进制有10个数码：0、1、2、3、4、5、6、7、8、9
  
  **基数**
  >数制所使用数码的个数。例如，二进制的基数为2；十进制的基数为10。
  
  **位权**
  >数制中某一位上的1所表示数值的大小（所处位置的价值）。例如，十进制的123，1的位权是100，2的位权是10，3的位权是1。二进制中的 1011 ，第一个1的位权是8，0的位权是4，第二个1的位权是2，第三个1的位权是1

  **常见的进制：**
  - 十进制
  - 二进制
  - 十六进制
  - 八进制
  #### 十进制：
  ⑴定义：以10位基数的计数体制简称十进制
  ⑵特点：
  ①系数：0、1、2、3、4、5、6、7、8、9
  
  ②计数规律：逢十进一，9+1=10
  
  ③权：基数的幂，即2的幂
  
  10的几次幂：右侧的第一位：10的0次幂=1  
        
             右侧的第二位：10的1次幂=10
     
             右侧的第三位：10的2次幂=100
  
 ![图片](https://hi-yee.github.io/coconut-blog/images/imageSoftwareTestingTheory/ct-02.png)

  **★现代计算机采用的是：冯诺依曼体系结构**
   #### 二进制：
   ⑴定义：以2位基数的计数体制简称十进制
   
   ⑵特点：

    ①系数：0、1

    ②计数规律：逢二进一，1+1=(10)2=(10)B（后缀B表示2进制）

    ③权：基数的幂，即10的幂

   2的几次幂：  右侧的第一位：2的0次幂=1
   
             右侧的第二位：2的1次幂=2
             
             右侧的第三位：2的2次幂=4
         
   ![图片](https://hi-yee.github.io/coconut-blog/images/imageSoftwareTestingTheory/ct-03.png)
    
   #### 十六进制：
   ⑴定义：以16位基数的计数体制简称十进制
   
   ⑵特点：

    ①系数：0、1、2、3、4、5、6、7、8、9、A、B、C、D、E、F

    ②计数规律：逢十六进一，F+1=(10)16=10H（后缀H表示16进制）

    ③权：基数的幂，即16的幂

   16的几次幂：  右侧的第一位：2的0次幂=1
   
             右侧的第二位：2的1次幂=2
             
             右侧的第三位：2的2次幂=4
  ![图片](https://hi-yee.github.io/coconut-blog/images/imageSoftwareTestingTheory/ct-04.png)
  ![图片](https://hi-yee.github.io/coconut-blog/images/imageSoftwareTestingTheory/ct-05.png) 
    
   #### 八进制：
   ⑴定义：以8位基数的计数体制简称十进制
   
   ⑵特点：

    ①系数：0、1、2、3、4、5、6、7、

    ②计数规律：逢八进一，7+1=(10)8=10O（后缀O表示8进制）

    ③权：基数的幂，即8的幂

   8的几次幂：  ③权：基数的幂，即8的幂
   
             右侧的第二位：8的1次幂=8
             
             右侧的第三位：8的2次幂=64
  ![图片](https://hi-yee.github.io/coconut-blog/images/imageSoftwareTestingTheory/ct-06.png)
  
  
  ### 进制转换：  
  任何进制都能转换成十进制
  
  方法：按权展开求和（用每一位的系数乘以本位的权，然后进行相加）
  
  ①、二进制——十进制
  ![图片](https://hi-yee.github.io/coconut-blog/images/imageSoftwareTestingTheory/ct-07.png)
  
  ②、十六进制——十进制
  ![图片](https://hi-yee.github.io/coconut-blog/images/imageSoftwareTestingTheory/ct-08.png)
  
  ③、八进制——十进制
  ![图片](https://hi-yee.github.io/coconut-blog/images/imageSoftwareTestingTheory/ct-09.png)
  
  ④、十进制——其他进制
  >方法：除基去余逆排法（例如：二进制基数为2）

  >求商和余数，再使用这个数，除于基数，求的新的商和余数，反复进行直到商为0.

  ![图片](https://hi-yee.github.io/coconut-blog/images/imageSoftwareTestingTheory/ct-10.png)

  ![图片](https://hi-yee.github.io/coconut-blog/images/imageSoftwareTestingTheory/ct-11.png)
  
  ⑤、二进制——十六进制
  理论：使用4位二进制数表示1位16进制数

  十进制、十六进制、二进制参照表
  
  ![图片](https://hi-yee.github.io/coconut-blog/images/imageSoftwareTestingTheory/ct-12.png)
  
  方法:从低位（右侧）起，每四为数分成一组，最高位不够4位补零，然后按照顺序写出对应的十六进制数。（4合一）
  
  ![图片](https://hi-yee.github.io/coconut-blog/images/imageSoftwareTestingTheory/ct-13.png)
  
  ⑦、二进制——八进制
  理论基础:使用三位数二进制数表示1位八进制

  十进制、八进制、二进制参照表
  
   ![图片](https://hi-yee.github.io/coconut-blog/images/imageSoftwareTestingTheory/ct-14.png)
   
   方法：从低位（右侧）起每一位3位数分成1组，最高位不够三位数补零，然后按顺序写出对应的八进制。（3合一）

   ![图片](https://hi-yee.github.io/coconut-blog/images/imageSoftwareTestingTheory/ct-15.png)
  
  ⑨、八进制——二进制
  方法:用3位数二进制表示一位八进制，去掉最高位零，然后按顺序排列二进制数（1分3）
  
  ![图片](https://hi-yee.github.io/coconut-blog/images/imageSoftwareTestingTheory/ct-16.png)
  
  
### 2、逻辑代数
  含义：逻辑代数是分析和设计逻辑电路的数学基础。
  
  逻辑代数是有英国科学家乔治.布尔（George. Boole）创立的，故称“布尔代数”
  ⑴、与运算
  
  ①逻辑与：只有当一件事的几个条件全部具备之后，这件事才发生。
  
  设：开关A、B不通——灯不亮
  
    开关A、B通——灯亮
    
  ②真是表：输入与输出的对应关系
  
   ![图片](https://hi-yee.github.io/coconut-blog/images/imageSoftwareTestingTheory/ct-17.png)
   
  总结：输入只要有0输出必有0；输入全是1输出才是1（有0出0，全1才出1）
  
  ③表达式： Y=A●B
  
           Y=AB
           
  ④运算规则：有0出0，全1才1
  
  列如：算A与B的与运算
  
   ![图片](https://hi-yee.github.io/coconut-blog/images/imageSoftwareTestingTheory/ct-18.png)
   
   补充：两个多位二进制，进行按位逻辑与运算
     
      右侧对齐，A与B对应的位分别进行与运算即可
      
      （前位不够当零处理，站位）
   
   ⑵、或运算
   
   ①逻辑或：当一件事的几个条件中只要有一个条件具备，这件事就会发生。
   
   设：开关A、B不通——灯不亮
   
   
    开关A、B通——灯亮
    
   ②真是表：输入与输出的对应关系
   ![图片](https://hi-yee.github.io/coconut-blog/images/imageSoftwareTestingTheory/ct-19.png)
   
  总结：输入只要有1输出必有1；输入全是0输出才是0（有1出1，全0才出0）

  ③表达式： Y=A+B
           
  ④运算规则：有1出1，全0才0
  
  列如：算A与B的或运算
  ![图片](https://hi-yee.github.io/coconut-blog/images/imageSoftwareTestingTheory/ct-20.png)
  补充：两个多位二进制，进行按位逻辑或运算
  
      右侧对齐，A与B对应的位分别进行或运算即可
      
      （前位不够当零处理，站位）
      
      
   ⑶、非运算
   
   ①逻辑非：一件事情的发生是以其相反的条件为依据的
   
   设：开关A通——灯不亮
   
    开关A不通——灯亮
  
  ②真是表：输入与输出的对应关系
    ![图片](https://hi-yee.github.io/coconut-blog/images/imageSoftwareTestingTheory/ct-21.png)
  总结：输入只要有0输出必有0；输入全是1输出才是1（有0出0，全1才出1）

  ③表达式： Y=—A（A非/A反） 
          
  ④运算规则：取反
  
  列如：算A的非运算
   ![图片](https://hi-yee.github.io/coconut-blog/images/imageSoftwareTestingTheory/ct-22.png) 

  **补充：多位二进制，进行按位取反 **  
  
## 第三章 软件缺陷和缺陷报告
  >- 测试人员的主要职责

  >- 编写缺陷报告

  >- 缺陷报告的处理流程

### 1、测试人员的主要工作职责
  >- ①编写测试计划
  >- ②编写测试用例
  >- ③执行测试，发现缺陷提交缺陷报告
  >- ④验证所发现的缺陷是否得到修改
  >- ⑤编写测试总结报告

### 2、编写缺陷报告
  当测试人员发现了一个缺陷，需要填写一份“缺陷报告”来纪录这个缺陷，
  并通过这个缺陷报告告知开发人员所发生的一个问题——测试人员和开发人员交流沟通的重要工具。
 
### 3、缺陷报告的组成
  >- ⑴、缺陷编号（Defect ID）：
  提交缺陷的顺序

  >- ⑵、缺陷标题（Summary）：
  简明扼要的描述一下缺陷

  >- ⑶、缺陷的发现者（Detected By）：
  测试人员自己

  >- ⑷、发现缺陷的日期（Detected on date）：
  区别：data数据   date日期
  一般是当天

  >- ⑸、缺陷所属的模块（subject）：
  在测试哪个模块是发现的bug（开发组可以据此决定由谁来修改bug）

  >- ⑹、发现缺陷的版本（Detected inrelease）：
  在测试哪个版本的时候发现的bug

  >- ⑺、指派给谁处理（Assigned to）：
  测试人员指派给开发经理

    **开发经理根据缺陷所在模块，需再次指派具体的开发人员。**

  >- ⑻、缺陷的状态（Status）：
  缺陷此时所处的处理阶段或处理情况

     >- ①、测试人员发现缺陷，提交缺陷报告，把缺陷报告状态设置为：New（新发现的bug）

     >- ②、开发经理验证新提交的bug，如果是bug，状态改成：open（打开的bug，开发已承认的bug），如果不是bug，把状态改为：rejected（拒绝的bug）——bug需要经过讨论

     >- ③、开发人员看到指派给自己的解决的bug，进行bug修复，修改完成后把缺陷状态改成fixed（已修复，可反测）

     >- ④、测试人员对修复的bug进行返测，返测成功，把状态改为closed（关闭的缺陷，归档的bug），如果返测不成功，把状态改为：reopen（重新打开的bug）（返测不成功）

    **说明：**
     - 以上的过程就是缺陷的标准处理流程
 
     - 一个缺陷的生命周期

  ⑼、缺陷的严重程度（Severity）
  Bug对软件影响有多大
  >- Urgent：造成系统死机、重启、崩溃的缺陷，影响整体
  >- Veryhigh：非常严重的缺陷
  >- High：严重的，大的缺陷
  >- Medium：中等程度的缺陷
  >- Low：小的缺陷

  **每一个等级到底包括哪些缺陷，最好专门的文档中详细进行说明，这样可以使开发人员和测试人员达成共识。**
  **Bug Level Definition（缺陷等级定义）**

  ⑽、缺陷的优先级★★★★★
  测试人员希望该缺陷程序员在什么时间内或在哪个版本中解决。
  >- Urgent：立刻修改（如果不改影响开发或测试的进度）
  >- Veryhigh：本版本修改
  >- High：下版本修改
  >- Medium：发布之前修改
  >-Low：允许在发布中存在的

  ⑾、缺陷描述（Description）★★★★★
  
  **把发现bug的步骤，使用的数据等记录下来，使程序员通过该描述就清楚所发生的事情。**

### 4、写缺陷报告时注意的问题？

  >- ⑴、一个报告只提交一个缺陷
  >- ⑵、缺陷描述清晰，准去易读，使用最少，必须的步骤，包装缺陷可以再现
  >- ⑶、对缺陷的严重性，优先级的划分准确
  >- ⑷、提交前一定认真审核，确保缺陷是否有效的，二不因为自己的不正当造成“假缺陷”
  >- ⑸、不要引起开发人员的重视而夸大缺陷
  >- ⑹、小的缺陷也要报告
  >- ⑺、及时报告缺陷
  >- ⑻、对不可重现的缺陷也要报告
  >- ⑼、不做任何评价

### 5、面试问题
  **⑴、缺陷的严重程度和优先级是不是成正比？**
  
  Eg：界面问题的严重程度一般比较低，但优先级可是最高的——立即修复
  其他重大功能个问题可能暂时解决不了，但是不影响软件其他功能的使用，这是优先级可能定义的比较低——在发布之前修复


  **⑵、缺陷的严重性和优先级确定好以后，还会改吗？**
  
  Eg：测试人员确定一个缺陷为立即修复——严重程度不能修改
  ——优先级可以修改

  **⑶、是不是所有已发现的缺陷都会被修复？**
  
  不影响用户使用的，后面再以补丁或软件升级的方式进行弥补
  
### 6、缺陷报告的用途
  >- ⑴、纪录bug
  >- ⑵、对缺陷进行分类
  >- ⑶、跟踪bug
  >- ⑷、对bug进行分析统计

### 7、如何识别bug
  >- ⑴、通过测试用例的预期结果判断——实际结果与预期结果不一致，就是bug
  >- ⑵、通过需求（通过缺陷的5点定义识别）
  >- ⑶、沟通（开发、需求、用户）
  >- ⑷、对bug进行分析统计

### 8、截图技巧
  >- ⑴、将要截图的页面显示出来，按下键盘“print Screen”打印屏幕，把当亲的界面当成图片，存在windows的剪贴板上
  >- ⑵、打开画图——开始——附件里面
  >- ⑶、Ctrl+V 黏贴
  >- ⑷、点击工具选定——新建一个文档——Ctrl+V 黏贴
  >- ⑸、Ctrl+all全选
  >- ⑹、到word里面黏贴

### 9、缺陷报告的处理流程
  测试人员            >-                 提交缺陷报告

  开发经理            >-               分配缺陷任务

  开发人员            >-              处理缺陷报告

  测试人员            >-                返测报告

  测试人员            >-              关闭缺陷报告

  **注释：返测报告通过才会关闭缺陷报告，不通过返回给开发人员重新处理缺陷报告**
  
## 第四章 使用等价类和边界值方法设计测试用例
  >- 测试用例的概念
  >- 使用等价类划分方法设计测试用例
  >- 使用边界值方法设计测试用例
### （一）测试用例的基本概念
  **基本概念：**
  
  > 执行之前的指导测试过程的文档，包括：用例编号、测试目的、用例描述、预期结果。
  
  **测试用例存在的意义：**
  >- 1、不知道是否全面的测试了所有内容
     
    -不知道所有功能点是否测试到了？
    -不清楚每个功能点是否测前面了？

  >- 2、存在大量的冗余测试，影响测试效率
   有些功能可能重复测试了多次

  >- 3、对新版本的重复测试很难实施
   每个版本测试的步骤、数据都不一样，随意性很强

  >- 4、测试的覆盖率无法衡量
   最后测试的好与不好不得而知

  **测试用例解决的问题：**
  测试用例主要是纪录了测试的过程、步骤、输入的数据、预期的结果等内容。
   它是在测试之前有测试人员编写的指导测试的重要文档。  
    
    解决了要测什么、怎么测和如何衡量的问题。

   **编写测试用例的参考相关文档：**
  >- 需求文档
 
  >- 开发文档

  >- 用户手册

  **★如果有软件的早期版本，尽快熟悉软件的使用**

  **★与相关的人员讨论**
  
### （二）写用例需要什么东西
  >- 1、相关文档（需要文档，用户手册，开发文档）
  >- 2、（对着）相应开发出的软件
  >- 3、与相关人员讨论

### （三）编写测试用例的方法
  #### 1、等价类划分法
   ⑴ 等价类划分与基本概念
  ① 应用场合
  只要有数据输入的地方就可以使用，从无线的数据中选取少数代表性的数据进行测试

  ② 核心概念
  - **有效等价类**
  
  - 对程序规则有意义，合理的输入数据集合，程序接收到有效等价类数据，可以正确执行、计算

  - **无效等价类**
  
  对程序规则没有意义，不合理的输入数据集合，程序接收到无效等价类数据，应该给出错误提示，或者根本不让用户输入
  
  >- ⑵ 使用等价类划分编写用例
  首先：先确定测试的对象
  对于初学者，先一个控件一个控件去测，在测一个控件的时候，保证其他空间不要出错。

  **案例一：**
  两位整数的计算，取值范围 { -99-99 }

  测试对象——第一个数文本框
  >- 1、根据需要划分等价类
  ** ①有效等价类**
  -99-99之间的整数
  **②无效等价类**
  - 非整数
  - <-99
  - >99

  >- 2、细化等价类
  - ①把第一步中不是特别细致的部分在详细划分 
  - ②有些情况不是根据显示需求，而是根据数据
  
  **存储方式的理解。**
  说明：
  - 数据在计算机中采用补码存储，而整数和负数的补码计算机公式不同，所以需要把正数和负数单独测。
  > Eg：把-99-99划分成

    -99-0   0-99
    
   - 非整数可以在进行细化：小数，字母，符号等。
    ![图片](https://hi-yee.github.io/coconut-blog/images/imageSoftwareTestingTheory/ct-23.png) 
    
  >- 3、建立等价类表（熟练后直接进行该步骤
     **有效等价类表**
     | 有效等价类  |
     | --- | --- |
     | 编号   |    数据要求 |
     | 1      |  -99-0 |
     | 2      |   0-99 |
     
     
   **无效等价类表**
     | 无效等价类  |
     | --- | --- |
     | 编号   |    数据要求 |
     | 1      |  <-99|
     | 2      |  >99 |
     | 3      |  小数 |
     | 4      |  字母 |
     | 5      |  汉字 |
     | 6      |  为空 |
     | 7      |  符号 |
     

  >- 4、编写用例
  从每个等价类中至少选取一个数据作为代表进行测试，即可。

    因为，穷举测试（把所有的数据都输一遍）是不现实的，但是不做穷举测试会存在风险，编写用例的方法，就是使用更合理的数据，在最少的测试成本的情况下，尽可能的降低风险。
    如果时间允许或者对某些数据有争议，可以把它作为用例。
  ![图片](https://hi-yee.github.io/coconut-blog/images/imageSoftwareTestingTheory/ct-24.png) 
  
  ![图片](https://hi-yee.github.io/coconut-blog/images/imageSoftwareTestingTheory/ct-25.png) 
  
  >- ⑶ 等价类划分的步骤
    >- ①划分等价类
   >- ②细化等价类
   >- ③建立等价类表
   >- ④编写测试用例
  >- ⑷补充的内容
   >- **①什么是字节？（1个字节=8位bit）**

   **位：**"位(bit)"是电子计算机中最小的数据单位。每一位的状态只能是0或1。
   
   **字节：**8个二进制位构成1个"字节(Byte)"，它是存储空间的基本计量单位。
   1个字节可以储存1个英文字母或者半个汉字，换句话说，1个汉字占据2个字节的存储空间。
   
   **字：**"字"由若干个字节构成，字的位数叫做字长，不同档次的机器有不同的字长。
   例如一台8位机，它的1个字就等于1个字节，字长为8位。如果是一台16位机，那么，
   它的1个字就由2个字节构成，字长为16位。字是计算机进行数据处理和运算的单位。
   >1KB=1024个字节bytes=210=1024
   >1MB=1024KB
   >1GB=1024MB
   >1TB=1024GB
   >1PB=1024TB
   >1EB=1024PB
   >1兆B=1024kb
   >1GB=1024兆B
 
   >- ②补码
   计算机当中正数是以补码表示的，一个正数的补码和其原码相同。（将一个数转换成二进制，前面添加0，加到补齐32位或者64位）

   对于负数，则存放补码的方法是：将该数的绝对值 二进制形式 按位取反 再加1
   Eg：求-11的补码分四步骤：
   >⒈ -11的绝对值是：11
   >⒉ 11的二进制形式为：1011
   >⒊按位取反0100
   >⒋再加1:0101

   >补齐32位：0000 0000 0000 0000 0000 0000 0000 1011
   >32位取反：1111 1111 1111 1111 1111 1111 1111 0100
   >32再加以：1111 1111 1111 1111 1111 1111 1111 0101

   32位存储方式的利弊：
  **利：**方便分配（一刀切-管理方便）
  **弊：**浪费空间
  
  #### 2、边界值法
  >- ⑴ 边界值基本概念
   - ① 应用场合
   只要有数据输入的地方就可以使用，有效无效数据的分界点，需要单独拿出来测试。
   
   **A、有数据范围的**
   - Eg：-99-99之间的合法整数

  **B、数据字符个数的要求**
  - Eg：姓名字符范围：1-20个字符

  **★★★ 边界值一般和等价类一起应用，找到有效无效数据的分界点（最大值和最小值）以及其两边的点，进行测试，形成一套完整的测试方案。**

  - ② 如何使用
  **说明**
  >边界值的数据，本质上可以分为有效无效的判断，单从测试技术角度来讲，需要单独拿出来测试（必要的冗余）
  
  >- ⑵ 测试用例的作用(好处)
     >- 防止遗漏：使软件测试的实施重点突出，目的明确，确保需求功能不被遗漏；
     >- 版本重复测试：快速正确的进行版本重复测试；
     >- 监督过程：可以准确，有效的评估测试的工作量；
     >- 评估结果：对产品进行评估，对测试完成的情况进行评价；
     >- 提高效率：避免盲目测试
     >- 缩短周期：版本更新和升级，只需修正少部分测试用例资源复用。

  >- ⑶ 写测试用例的注意点
  >- ① 在编写测试用例之前，还需要明确项目对测试用例的具体需求：
  - A、测试用例编写如何命名
  - B、测试用例中用到的附件命名规定，存放位置
  - C、测试用例应该提交到什么地方

  >- ② 测试用例是需要更新和维护的，是一个不断修改完善的过程；

  >- ③ 测试用例需要正式的评审；

  >- ④ 测试用例覆盖的程序决定测试的覆盖程度。

  >- ⑷ 对测试人员的要求

  >- ① 基本要求——在编写测试用例时，要求步骤描述清晰，准确，易读，预测结果明确。
  - A、如果有特殊的设置，预支条件等要明确写出；
  - B、如果有输入数据，一般要给输入数据取值；
  - C、如果有附件，要给出附件存放位置，名称。

   **★★★ 检验标准：**
   
   写完用例后，让别人照着自己写的用例去执行，测试，可以很顺畅的执行下来。

  >- ② 高标准要求
  测试用例编写有条，有理，逻辑性强
   - 可以按照功能点分类，操作顺序逻辑年写，不要一会测这里，一会测那里

   - 功能覆盖全面，深入，能够发现软件中更过缺陷

   **★★★ 检验标准：**
   
   能把软件中的缺编尽可能多的找出来，按照你的测试用例测试完成的软件，遗留的缺陷最少——要求测试人员最终达到的目标，是一个需要长期联系，积累的过程。

  >- ⑸ 用例的优化
  >- ① 对于不同的控件的有效等价类一有效边界值可以尽可能在一条用例中进行测试。不同控件的有效等价类及有效边界可以组合测试——减少用例数量。

  >- ② 在一条用例中，先一次只测试一个空间的无效等价类强

  > 无效等价类在开始的时候不能组合
  > 避免“屏蔽”现象的发生
  > 想测试一下（验证）软件处理极端数据的能力

  **★★★ **
  **“屏蔽”现象指的是：前面的控件的错误提示一出现，后面的错误现象就不出现了——最后仔适当考虑无效等价类的组合**

  **★★★** 
  **字符包括：字母、符号、数字（0-9）、汉字**
  
  >- ⑹ 等价类划分经验
  >- ①有效等价类一般可以直接在需求中找到
  >- ② 无效等价类
  > 如果是必填项（不能为空）——————为空
  > 不是重复的————————————重复
  > 数据有范围————————————超出范围
  > 又字符个数要求——————————超出范围
  > 填写项允许的格式（整数，小数，字符）
  > 针对小数，小数点后的位数要求
 
  **★★★ **
  **说明：**
  **每个控件的有效等价类和有效边界的数量，一遍不会完全相等，会造成编写用例的数据的冗余，（测过的数据再选一次货多次）**
  
  #### 3、因果图法
  >- ⑴ 因果图基本概念
① 应用场合
  在一个界面有多个控件，测试的时候要考虑控件的组合关系，不同的控件组合胡产生不同的输出结果。结果的组合，为了弄清楚输入组组合会产生什么样的输出组合，使用因果图法。

  >- ⑵ 因果图的核心要点
  - ①因——原因，输入条件
  - ②过——结果，输出结果
  
  使用图形的方式，来分析软件输入和输出的对应关系
  
  >- ⑶ 图形符号
  ##### - **①基本图形符号——表示输入和输出的对应关系**
  >- A、恒等★★★★★
    a     恒等        b
 >![图片](https://hi-yee.github.io/coconut-blog/images/imageSoftwareTestingTheory/ct-26.png) 
  - a是输入；b是输出
  **含义：若原因出现，则结果出现，若原因不出现，则结果也不出现**
      
       - 若 a=1，则 b=1
      
       - 若 a=0，则 b=0

  >- B、非（～）
  ![图片](https://hi-yee.github.io/coconut-blog/images/imageSoftwareTestingTheory/ct-27.png) 
   a     非        b

  - a是输入；b是输出
  ** 含义：若原因出现，则结果不出现，若原因不出现，则结果出现
      若 a=1，则 b=0
      若 a=0，则 b=0

  >- C、或（∨）
  ![图片](https://hi-yee.github.io/coconut-blog/images/imageSoftwareTestingTheory/ct-28.png) 
  - a是输入；b是输出
  ** 含义：若几个原因中有一个出现，则结果出现，若几个原因都不出现，则结果不出现
      若 a=1，或 b=1，或 C=1，则 d=1
      若 a=b=c=0，则 d=0

  >- D、与（∧）★★★★★
  ![图片](https://hi-yee.github.io/coconut-blog/images/imageSoftwareTestingTheory/ct-29.png) 

  - a是输入；b是输出
  ** 含义：若几个原因都出现，结果才出现，若其中有一个不出现，则结果不出现
      若 a=0，或 b=0，或 C=0，则 d=0
      若 a=b=c=1，则 d=1
  
  ##### - **② 约束（限制条件）图形**
  要不然单独限制输入，要不单独限制输出。不能一次既限制输入和输出。**
  
  >- A、互斥（E）
 
  ![图片](https://hi-yee.github.io/coconut-blog/images/imageSoftwareTestingTheory/ct-30.png) 
  - a，b，c是输入；d是输出
  ** 含义：a、b、c三个原因不会同时成立，最多有一个可能成立，a、b、c不能同时为1，即a、b、c中至少有一个为1
      
      

  >- B、包含（I） 
  ![图片](https://hi-yee.github.io/coconut-blog/images/imageSoftwareTestingTheory/ct-31.png) 

  - a，b，c是输入；d是输出
  ** 含义：a、b、c三个原因至少有一个必须成立，a、b、c不能同时为10，即a、b、c中至少有一个为1

  >- C、唯一（O）
  ![图片](https://hi-yee.github.io/coconut-blog/images/imageSoftwareTestingTheory/ct-32.png) 
  - a，b，c是输入；d是输出
  ** 含义：a、b、c三个必须有一个成立，有且仅有一个成立

  ** 说明：唯一的情况是有一个默认值，而互斥没有默认值。

  >- D、要求（R）
  ** 含义：表示当a出现时，b必须也出现
  **若a=1，则b=1，即不可能a=1且b=0

  >- E、屏蔽（M）

 ** 含义：a=1，则b必须为0，而当a为0时，b的值不一定

  >- ⑷ 使用因果图法分析程序
  - Eg：交通一卡通自动系统充值模拟系统
  ![图片](https://hi-yee.github.io/coconut-blog/images/imageSoftwareTestingTheory/ct-33.png) 
  
  >- (1)步骤一：找出所有的原因编号（输入编号）
  - ①投币50元
  - ②投币100元
  - ③充值50元
  - ④充值100元
  - 能组合的：①+③、①+④、②+③、②+④
  - 不能组合的：①+②、③+④
  - 可以单独组合：①、②、③、④

  >- (2)步骤二：找出所有的结果编号（输出编号）
  - A、充值成功并退卡
  - B、提示充值成功
  - C、找零
  - D、提示错误
  - 必须一起的：A+B
  - 不能组合的：A+D、B+D
  - 能组合：A+B+C、C+D、D

  >- (3)步骤三：在步骤一的基础上找到输入的限制关系和组合关系——决定了测试用例的多少
  >- A、限制关系，（哪些不能组合仔一起（有制约关系））
  - 输入①+②——互斥
  - 输入③+④——互斥

  >- B、组合关系（决定测试用例的数量）
  - ⒈输入（1）和（3）组合
  - ⒉输入（1）和（4）组合
  - ⒊输入（2）和（3）组合
  - ⒋输入（4）和（3）组合
  - ⒌输入（1）单独
  - ⒍输入（2）单独
  - ⒎输入（3）单独
  - ⒏输入（4）单独

  >- (4)步骤四：在步骤二的基础上，找到输出的限制关系和组合关系

  - （1）限制关系
  - ①输入A+D不能（互斥）
  - ②输入B+D不能（互斥）

  - （2）组合关系
  - ①输出A和B必须组合
  - ②输出A、B、C组合
  - ③输出C和D组合
  - ④输出D单独

  - 步骤3、4是深入分析需求的过程

  >- (5)步骤五：找到输入组合和输出组合的对应关系（什么样的输入组合会产生什么样的输出组合）——一依据步骤三（2）和步骤4（2）

  >- 情况一： 
  - 输入（1）和（3）组合
  - 会产生：A和B必须组合
  >- 情况二：
  - 输入（1）和（4）组合
  - 会产生：C和D组合

  >-情况三：
  - 输入（2）和（3）组合
  - 会产生：A、B、C组合

  >- 情况四：
  - 输入（4）和（3）组合
  - 会产生：A和B必须组合

  >- 情况五：
  - 输入（1）单独
  - 会产生：C和D组合

  >- 情况六：
  - 输入（2）单独
  - 会产生：C和D组合

  >- 情况七：
  - 输入（3）单独
  - 会产生：D单独

  >- 情况八：
  - 输入（4）单独
  - 会产生：D单独
  
  ** 测试用例展示:
    ![图片](https://hi-yee.github.io/coconut-blog/images/imageSoftwareTestingTheory/ct-34.png) 
    
  ** ★★★因果图形符号总结：  
    ![图片](https://hi-yee.github.io/coconut-blog/images/imageSoftwareTestingTheory/ct-35.png)   
    ![图片](https://hi-yee.github.io/coconut-blog/images/imageSoftwareTestingTheory/ct-36.png)  
    
  #### 4、使用判定表法设计测试用例
  ** 判定表法就是因果图的简化，步骤完全一样，省略画图过程。
  >- 案例一：
   ![图片](https://hi-yee.github.io/coconut-blog/images/imageSoftwareTestingTheory/ct-37.png)
  >- 判定表:
  ![图片](https://hi-yee.github.io/coconut-blog/images/imageSoftwareTestingTheory/ct-38.png)
  >- 测试用例：
  ![图片](https://hi-yee.github.io/coconut-blog/images/imageSoftwareTestingTheory/ct-39.png)
  >- 案例一总结：
  >- 当输入数据的时候，可以把需求中的要求的么一个输入项（范围）当做是一个条件。
  >- 适合使用判定表设计测试用例的条件
  - ⑴ 规格说明书一判定表的形式给出，或很容易转换成判定表的。
  - ⑵条件的排列顺序不影响执行。
  - ⑶规则的排列顺序不影响执行那些操作
  - ⑷当某一些规则的条件已满足，并确定执行的操作后，不必检验别的规则。
  - ⑸如果某一规则呀执行多个操作，这些操作的执行与顺序无关。
  
    
  #### 5、使用正交排列法设计测试用例
  >- ⑴ 应用场合

    在一个界面中，有多个控件，每个控件又有多个取值，控件取值组合数量很大，不可能（也没有必要）为每一种组合编写一条用例。
    如何使用最少最有的组合进行测试————正交排列法

  - 区别：判定表（因果图）也是考虑控件组合，但是组合的数量较少（一般不会超过20种），而且要求测试全面。
  
  >- ⑵ 正交表

  **含义：正交表是一种特制的表，一般的正交表及为Ln（mK）
  - ① n是表的行数，也是需要测试组合的次数
  - ② k是表的列数，表示控件的个数
  - ③ m是每个控件包含的取值（个因素的水平数，即各因素的状态数）

  ** Eg：L9（34）
  - 有4个控件
  - 每个控件有3个取值
  - 9位需要测试的组合个数
  >- ⑶ 使用正交排列法来分析程序

  - ① 分析需求————把空间及其取值列举出来
  - ② 根据控件和控件取值个数，选择一个合适的正交表
     - A、根据控件的个数，选择正交表的次幂，也就是正交表的列数
     - B、 根据控件取值的个数，选择正交表的底，也就是正交表中包含数的最大值

  - ③ 把空间及其取值映射到（放到）正交表中
     - A、把控件名称分别放到正交表的列名位置上
     - B、把正交表中每一列的数字分别用控件的取值代替

  - ④ 根据正交表，编写用例
    - 把正交表的一行转换成一条用例
  ** ★★★说明：★★★
  使用正交表设计的用例是最少的，最优的用例，如果时间允许，可以补充案例。

  - ⑤ 正交表的种类
     - A、各水平数相同的正交表
     - B、混合水平正交表
  **★——L8（4*24）——一个控件有4个属性，4个控件有2个属性（属性即使取值）
  >- ⑷ 使用正交表排列法的局限性

**目前常见的正交表排列法只有附件中给出的几种，即使是已有的正交排列表，基本要求每个控件的取值要相等，这在实际软件中很好遇到！
正交表个数有限，并且一般要每个控件的取值个数相等，在实际软件中很好遇到。

  >- ⑸ 正交表选择数据的思想（没有现成的正交表怎么办？）
  ** 公平，均匀
  - 1、每个控件都要参与组合，每个控件的取值参与组合的次数尽量相同
  - 2、从所有的组合数据应均匀零星的挑选，作为用例的组合数据，而不是仅从某个局部选取的。
  
  >- ⑹ 案例二：（ppt打印功能测试）

  - 方案一：少数服从多数
    - 有更多的控件取值一样——有2个控件取值为3，底选3。
    - 次幂（没有争议）：控件的个数，如果在正交表，没有就选择一个接近，4个控件，选4次幂
    ![图片](https://hi-yee.github.io/coconut-blog/images/imageSoftwareTestingTheory/ct-40.png) 
    ![图片](https://hi-yee.github.io/coconut-blog/images/imageSoftwareTestingTheory/ct-41.png) 
    ![图片](https://hi-yee.github.io/coconut-blog/images/imageSoftwareTestingTheory/ct-42.png) 
  - 方案二：取值最多原则
    ![图片](https://hi-yee.github.io/coconut-blog/images/imageSoftwareTestingTheory/ct-43.png) 
    ![图片](https://hi-yee.github.io/coconut-blog/images/imageSoftwareTestingTheory/ct-44.png) 
    ![图片](https://hi-yee.github.io/coconut-blog/images/imageSoftwareTestingTheory/ct-45.png)
     
  #### 6、使用场景法设计测试用例
  >- ⑴ 应用场合
  - ① 界面特点
  没有太多填写项，主要通过鼠标的点击，双击拖拽等完成操作。

  - ② 把自己当做最终的用户，在使用该软件的时候可能会遇到哪些情形（场景法）
  主要测试目的是测试软件的主要任务流程，主要功能的正确性和主要错误处理能力。
  >- ⑵ 核心概念
  - ① 基本流（正确流）
  模拟用户正确的操作流程——验证软件的业务流程和主要功能

  - ② 备选流——（错误流）
  模拟用户错误操作流程——验证软件的错误处理能力。


  >- ⑶ 总结
  - ① 场景法是基于等价类划分的一种测试方法（从技术上没有新内容）

  - ② 场景法的应用是基于对软件业务（需求）的深入理解（从业务层面）

  >- ⑷ 使用场景法分析程序
  ** 案例：模拟正确的取款流程
  ![图片](https://hi-yee.github.io/coconut-blog/images/imageSoftwareTestingTheory/ct-46.png)

  - ① 根据需求，找到基本流和备选流（找到正确的操作流程和可能出错的环节）
    - A、基本流——正确取款
    - B、备选流——出错的环节
    - C、提款机提款测试  
       - ⒈银行卡错误
       - ⒉密码错误
       - ⒊密码错误3次
       - ⒋卡内余额不足
       - ⒌超出当日可取
       - ⒍ATM余额不足
                  
  - ② 列出场景：把每一个基本流和备选流当做一个场景 
   ![图片](https://hi-yee.github.io/coconut-blog/images/imageSoftwareTestingTheory/ct-47.png) 
   ![图片](https://hi-yee.github.io/coconut-blog/images/imageSoftwareTestingTheory/ct-48.png) 
   ![图片](https://hi-yee.github.io/coconut-blog/images/imageSoftwareTestingTheory/ct-49.png)
  
  - ③ 根据场景编写用例
    - 写出场景，不用写用例
    测试的时候留下证据
    
  #### 7、测试大纲法
  >- ⑴ 应用场合
在一个程序中设计多个窗口，每一个窗口有多个控件，窗口与窗口中有一定的联系（或者说操作之间的联系，）为了弄清楚他们之间的联系，使用测试大纲法。

  >- ⑵ 使用测试大纲法分析程序
  - ① 列大纲（提纲）——分析需求——把所有的窗口一树状结构，且根于每一个叶节点之间存在唯一途径。

  - ② 找到窗口与窗口之间（操作关系）的关系，编写用例

  - ★扩展：“列表框”和“下拉列表框”和“组合列表框（既有文本框+下拉列表框）”

  在进行测试时，一般至少测试三项，第一项，最后一项，中间某一项。
 
  ** ★★★★★测试大纲法小结
  - 大纲是一种着眼于需求的方法，为了列出各种测试条件，将将需求转换为大纲的形式。

  - 在根和每一个节点之间存在唯一的路径，每条路径定义了一个特色的输入条件几个，用于定义测试用例。
  
  
  #### 8、状态转换图（比较复杂，工作比较少用，效率低，面试可能用到）
  #### 9、测试用例方法选择综合策略
  ##### 一、最最重要的方法
  >- 1、场景法
   - 为了测试程序的主要业务流程，主要功能和错误处理能力（也包括等价类划分）
   -    基本流：模拟正确的操作流程（验证软件的业务流程和主要功能）
   -    备选流：模拟用户错误操作流程（验证软件的错误处理能力）
   -    Eg：案例
       模拟ATM机提款机的测试过程

  >- 2、等价类划分
   -    只要有数据输入的地方（包括选择数据的地方），把无限的数据进行等价类划分，可以减少用例的数量。
   -    有效等价类：对程序规格有意义，合理的输入数据集合，程序接收后能正确执行，计算
   -    无效等价类：对程序规格无意义，不合理的输入书库集合，程序接收后应给出错误提示，或根本不让用户输入。
   -    Eg：用户登录，信息输入等
  ##### 二、重要
  >- 1、边界值
    -   找到数据（有效数据、无效等价类的分界点）对分界点（最大值、最小值）及其两边的点进行测试。

   - 一般有数据范围：如编号：1-500整数
   - 数据长度：如姓名：1-20个字符——要求的控件
   - 说明：在实际工程中，由于需求不明确，有时可能数据的范围未能确定，这种情况下，边界只能不测。
      
  >- 2、判定表（因果图）
   - 考虑多个控件的组合会产生不同的输出组合（组合数量较少，而且要求考虑全面）
    -   九个图形符号：
   -    4个基本符号：恒等，或（∨），非（~）（饭），与（∧）
   -    5个限制条件符号：互斥（E），包含（I），唯一（O），要求（R）、屏蔽（M）
  ##### 三、次重要
  >- 1、正交排列法
   - 多个控件有多个取值，考虑不同控件取值的组合（参数配置类软件）（组合数量大）（而且没有必要全部测试）
   - 使用最少的组合达到最大的覆盖程度。

  >- 2、测试大纲法
   - 涉及到多个窗口，每个窗口包含多个动作，找到每一个窗口的动作之间的联系
   - Eg：软件安装流程
  
## 第五章 软件测试基本理论
  - 软件开发阶段划分
  - 软件测试阶段划分
  - 软件测试模型
  - 软件测试分类

### 1、软件开发阶段划分
  - ▶ 需求分析     
  - ▶ 概要分析
  - ▶ 详细分析     
  - ▶ 编码 
 >-（一）需求分析
     根据客户的要求，清楚了解客户需求中的产品功能，性能界面和具体规格等，然后进行分析，确定软件产品所要达到的目的。
————输出“需求说明规格书”
 >-（二） 概要分析
    
    系统分析员审查软件计划，软件需求分析提供的文档，提出候选的最佳方案，确定模块结构，划分功能模块将软件功能需求分配，
 - 输出“概要设计说明书”
 >-（三）详细分析

    根据客户的要求，清楚了解客户需求中的产品功能，性能界面和具体规格等，然后进行分析，确定软件产品所要达到的目的。
 >-（四）编码

    通过某种编码语言编写程序。

 - 哪个阶段引入的缺陷最多？
 - 需求说明书：56%；程序设计：25%；编写代码：13%；其他：6%。
### 2、软件测试阶段划分
  - ▶ 单元测试     
  - ▶ 集成测试
  - ▶ 系统测试     
  - ▶ 验收测试
  >- （1）单元测试
  - ① 依据是详细设计文档
  - ② 以功能测试为主，重点核心模块可以进行白盒测试（检查代码）
  - ③ 可能需要编写驱动模块或桩模块
   驱动模块：模拟被测试的上一级模块（调用被测试模块的那个模块）
   桩模块：模拟被测试模块的下一级模块（被测试模块调用的那个模块）
  - ④ 在实际工程中，为了节约成本，单元测试经常只由开发人员完成，有悖于测试思想（测试必须由第三方来完成）
  - 最小的测试单位
  >- （2） 集成测试
  - ① 拿到一个新的集成版本的时候，一般先做冒烟测试
   ————利用较少的时间（0.5-2天），较少的人（1-3人），经验更丰富的人，对软件的主要功能进行测试，主要判断该版本是否值得一测，整个测试组再全部投入，如果不值得一测，打回开发组，令其完善再给出新的版本。 
  - ② 一个新的版本测试思路
    - A、冒烟测试
    - B、返测：对已发现的缺陷是否进行修复的测试
    - C、回归测试：对前面版本中所有的用例再执行一遍（保证软件的功能正确）
    - D、对新添加的功能进行测试
  >- （3）系统测试
  - ① 对整个软件系统进行完整的测试过程
  
  - ② 在系统测试之前，一般有“确认测试”
    - A、确认测试：确认程序值不值得一测（冒烟测试）
    - B、确认相关文档是否齐全


  >- （4）验收测试
  用户接受测试，用户体验 UAT（user acceptance test）

    - alpha测试：由最终的用户在开发环境中，对软件进行测试（在实际中也经常有开发方自主完成）
    - beta测试：由最终的用户在实际的环境中进行测试试用


  ** ★★★★ 对于一些没有固定用户群体的公共软件（办公软件，游戏，输入法），一般会发行公测版（beta版）
  让用户免费试用，发现bug后进行信息反馈。
### 3、软件测试模型

   >- （一）概念：测试模型体现的是开发和测试的对应关系
   ** V模型
>![图片](https://hi-yee.github.io/coconut-blog/images/imageSoftwareTestingTheory/ct-50.png)
   - ① 优点：
   测试阶段明确，既包括单元级（可能涉及代码）也包括用户级与开发级关系的明确
   
   - ② 缺点：
   容易理解成测试只是开发后的一个工作，不符合越早测试好不断测试原则
   
   - ③ 深入理解
   在编码之前，我们需要对相关需求文档进行测试——越早测试
   - 根据相关文档，在测试执行之前编写各个阶段的测试计划。
      - 测试用例文档等————测试过程是有计划性的——

   - 注意：（至少条件）
   - 如果做单元测试,需要有——详细设计文档
   - 如果做集成测试,需要有——概要设计文档
   - 如果做系统测试,需要有——需求文档
   - 如果做验收测试,需要有——需求设计文档


   >-（二）W模型
   ![图片](https://hi-yee.github.io/coconut-blog/images/imageSoftwareTestingTheory/ct-51.png)
   ** 优点：符合尽早测试和不断测试的原则。
   - 符合测试实际工作中的测试活动

### 4、软件测试的分类   
  >- （一）按照测试技术划分
  - ① 黑盒测试（功能测试）
    - ▶ 黑盒测试法把对象看成一个黑盒子，完全不考虑程序内部结构和处理过程，通过软件的外部表现来发现某缺陷和错误。
    - ▶ 黑盒测试是在程序界面处进行测试，它只是检查程序是否按需求规格说明书的规定正常实现。
    - ▶ 黑盒测试一般也称“功能测试”

  ** X=2——————？——————y=2
  - ② 白盒测试（逻辑/结构测试）——通过软件代码进行检查
    - ▶ 白盒测试可以把程序看成在一个白色透明的白盒子里，也就是清楚了解成粗结构和处理过程，检查是否所有的结构及路径都是正确的，检查软件内部动作是否按照设计说明的规定正常进行。
    - ▶ 白盒测试又称“结构测试”

  ** X=2——————y=2x——————y=4
  黑盒测试和白盒测试的区别

 |黑盒测试 |	白盒测试 |-----|	
 |规划方案	|	---	|	针对结构的测试|	
  |	优势方面|		能确保从用户角度出发进行测试	|	能够对程序内部的特定部位进行覆盖测试|	
  |	 应用举例	|	等价类划分、边界值分析法、因果图法、判定表 |		语句覆盖、判断覆盖、条件覆盖、判断条件覆盖、基本路径覆盖、循环覆盖、模块接口测试|	


  - ③ 灰盒测试
    - ▶ 介于白盒测试与黑盒测试之间的测试
    - ▶ 灰盒测试结合了白盒测试和黑盒测试的要素。灰盒测试关注输出对于输入的正确性；同时也关注内部表现，但这种关注不像白盒测试那种详细，完整只是通过一些表征性的现象事件。标志来判断内部的运行状态。

    - 总结
  ** 白盒测试的重点是看代码的逻辑，算法结构是否正确，要求必须看的懂代码，需要编写测试用例。

    - 在单元测试时，白盒测试应用相对较多
    - 在集成测试时，灰盒测试应用相对较多
    - 在系统测试时，验收测试时，一般就不会使用白盒和灰盒测试。


  >- （二）按照测试技术划分
    - ◆ 静态测试（界面、文档、代码）
    - ◆ 动态测试
  - ① 静态测试
    - ▶ 静态测试是指：不实际运行被测软件，而是静态地检查程序代码、界面或文档可能存在错误的过程。
    - ▶ 静态测试技术又称为静态分析技术，实际上是对软件需求说明书，程序源代码等进行非运行的检查
    - ▶ 静态测试包括：代码测试、界面测试、文档测试等
    -  代码测试：主要测试代码是否符合相应的标准的规范
    -  界面测试：主要测试界面是否与需求说明相互
    -  文档测试：主要测试用户手册和需求说明是否真正符合用户的实际需求。
  - ② 动态测试
    - ▶ 动态测试是指：通过人工或使用工具运行程序检查分析程序执行状态和程序的外部表现。
    - ▶ 实际运行被测试程序。输入相应的测试数据，检查实际输出结果和预期结果是否相符。

  >- （三）按照软件特性划分
    - ◆ 功能测试
    - ◆ 性能测试
  - ① 功能测试
    - ▶ 根据产品特征，操作描述和用户方案，测试一个产品的特性和可操作行为确定它们是否满足设计需求。 

  - ② 性能测试——分布式软件（B/S，C/S）
    - B/S：客户端只需要有浏览器就能访问服务器（京东商城，百度等）
    - C/S：客户端需要有专门的软件才能访问服务器（比如：QQ，MSN）

    - ▶ 评价一个产品或组件性能需求是否符合的测试，包括负载测试，压力测试，数据库容量测试等。

  >- （四）返测
    - ▶ 针对程序员修改的错误进行测试，验证错误是否被修改。

  >- （五）回归测试
  - ▶ 回归测试是指：针对软件的新版本测试时，重复执行上一个版本测试时的用例。

  - 在发生修改之后重新测试新版本的软件已保证修改的真确性，以及修改后没有引发新的错误。

  >- （六）冒烟测试
  - ◆ 冒烟测试是指在对一个新版本进行大规模的测试之前，先验证软件的基本功能是否实现，是否具备可测性。

  - ◆ 冒烟测试又称版本验证测试。冒烟测试的对象是每一个新编译的需要正式测试的软件版本，目的是认证软件的基本功能正常，可以进行后续的正式的测试。

    - ◆ 简单地说，冒烟测试就是用较少的人，在较短的时间内测试程序的主要功能，如果通过再进行正式的测试。
  >- （七）随机测试
    - ◆ 随机测试也称：猴子测试，是指测试中所有中所有的输入数据，都是随机产生成的，其目的是模拟用户的真实操作，随意向系统输入操作。
    - ◆ 性能测试


## 第六章 测试管理工具 Quality center
### 1、二级标题
### 2、二级标题
### 3、二级标题
### 4、二级标题
### 5、二级标题

## 第七章
### 1、二级标题
### 2、二级标题
### 3、二级标题
### 4、二级标题
### 5、二级标题

## 第八章
### 1、二级标题
### 2、二级标题
### 3、二级标题
### 4、二级标题
### 5、二级标题

## 第九章
### 1、二级标题
### 2、二级标题
### 3、二级标题
### 4、二级标题
### 5、二级标题

## 第十章
### 1、二级标题
### 2、二级标题
### 3、二级标题
### 4、二级标题
### 5、二级标题

## 第十一章
### 1、二级标题
### 2、二级标题
### 3、二级标题
### 4、二级标题
### 5、二级标题



