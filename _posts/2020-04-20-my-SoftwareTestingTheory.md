---
layout:     post                    # 使用的布局（不需要改）
title:      软件测试基础理论              # 标题
subtitle:   作为想入门测试行业的你，这是必须要了解的理论知识     #副标题
date:       2020-04-20              # 时间
author:     coconut                      # 作者
header-img:    #这篇文章标题背景图片
catalog: true                       # 是否归档
categories: 软件测试
tags:                               #标签
    - 软件测试
---
# 软件测试的分类

[TOC]
## 第一章 计算机基础
### 1、什么是软件
  软件是计算机系统与硬件相互依存的另一部分。它包括程序与文档的完整集合。
  * **程序：**（program）是为实现特定目标或解决特定问题而用计算机语言编写的命令序列的集合。为实现预期目的而进行操作的一系列语句和指令。
  * **文档：**
    - 文档是一种对软件系统的书面描述；
    - 文档应当精确地描述软件系统；
    - 软件文档是软件工程师之间用作沟通交流的一种方式；
    - 文档的类型有很种，包括软件需求文档，设计文档，测试文档，用户手册等；
    - 文档的呈现方式有很种，可以是传统的书面文字形式或图表形式，也可是动态的网页形式。  
### 2、什么是软件缺陷
  怎么判断是否是缺陷？
  * 缺陷的定义一：
  > **五个规则**

  >- 1、软件未实现产品说明书要求的功能；（列如：手机不能发信息）
  >- 2、软件出现了产品指明不应该出现的错误；
  >- 3、软件实现了产品说明书未提到的功能；（画蛇添足）
  >- 4、软件未能实现说明虽未明确提及，但应实现的功能
  >- 5、软件难以理解，不易使用，运行缓慢，或者从测试员的角度看，最终用户会为人不好。
  * 软件缺陷的定义二：
  >- 美国电气和电子工程师协会（IEEE）对缺陷的定义：
  >- 从产品内部看，缺陷是软件产品开发或维护过程中存在的错误和毛病等各种问题。
  >- 从产品外部看，缺陷是系统所需要实现的某种功能的失效或违背。
  >- 简单的说，用户在软件使用的过程中，遇到的任何错误、异常都可以称之为“软件缺陷”
### 3、什么是软件测试
  现有的软件寻找缺陷，软件测试的过程就是寻找缺陷的过程。
  英语：Software Testing），描述一种用来促进鉴定软件的正确性、完整性、安全性和质量的过程。换句话说，软件测试是一种实际输出与预期输出间的审核或者比较过程。软件测试的经典定义是：在规定的条件下对程序进行操作，以发现程序错误，衡量软件质量，并对其是否能满足设计要求进行评估的过程。
### 4、软件测试的历史
  Bug的由来
  一般我们把软件缺陷（Defect）成为bug（臭虫）
  1947年，哈佛大学制造的马克二型（Mark Ⅱ）计算机
  这个项目的领导者是Grace Hopper （格雷斯.哈珀-1906-1992）
  曾经担任过美国海军将军，著名的计算机语言cobol编译器的发明者，计算机业有史以来最杰出女性，Cobol语言设计者，设计第一个编译程序，发现世界上第一个BUG。

  > 测试的对象：文档 
  * ①需求规格说明书
  * ②软件概要设计说明书
  * ③软件详细设计说明书
  * ④用户帮助手册
  * ⑤测试用例
### 5、计算机的层次
![图片](https://hi-yee.github.io/coconut-blog/images/imageSoftwareTestingTheory/ct-01.png)
  
提问：
裸机包含软件吗？
答：裸机也包含软件，主要是BIOS程序（Basic input/output system）=基本输入/输出系统
存在何处：存在主板上的一块cmos芯片中。
开机快速按delete（删除键）键进入BIOS系统（笔记本一般为功能键f4）

（裸机中软件）作用：计算机接通电源后，首先由BIOS程序，BIOS对计算机进行硬件“商店自检”，检查所有硬件是否连接完好，如果连接有问题，通过蜂鸣器发出精神，并停止计算机的启动，如果没有问题，将吧控制权交给操作系统。

常见的计算机操作系统有：
Windows   +   Unix   +   Linux   +   苹果
### 6、软件的分类
  (1)软件基本分类：系统软件+应用软件
   系统软件：包括操作系统、操作系统补丁程序、驱动程序（操作系统的内核程序通过调用硬件的驱动程序完成硬件管理功能）
  
  **操作系统（Operating system，简称OS）的主要功能：**
  - 硬件（设备）管理：通过驱动程序，调度控制硬件设备。
  - 进程管理：对运行的程序进行管理。
  - 存储（内存）管理：下内存可以运行大程序。
  - 文件管理：管理文件和文件夹

   **那些软件属于支持服务工具？**
   - 硬件测试软件
   -（3D Mark 显卡评测）
   - 防病毒程序

  **常见的数据库管理软件有哪些？**
  - SQL server 2008
  - oracle
  - My SQL

   (2)按照软件结果分类（看软件的运行是否基于网络）
   >不是，单机软件

   >是，分布式软件

   - C/S结果（client/server客户端/服务器结构）客户端需要使用专门的软件访问服务（列如：QQ，MSN，需要注册账号）
   - B/S结果（Browser/server浏览器/服务器结构）客户端只需要有浏览器就能访问服务网站。（列如：京东商城论坛，百度等）

   **如何区分C/S结构和B/S结构软件**
   > 主要看客户端需不需要安装专门的软件
   - 需要——C/S结构
   - 不需要——B/S结构

## 第二章 进制转换
### 1、进制转换
  **数制的概念：**
  >数制也称进制，是指用一组固定的符合和统一的规则来表示数值的方法。任何一个数制都包含两个基本要素：基数和位权。

  **数码**
  >数制中表示基本数值大小的不同数字符号。例如，十进制有10个数码：0、1、2、3、4、5、6、7、8、9
  
  **基数**
  >数制所使用数码的个数。例如，二进制的基数为2；十进制的基数为10。
  
  **位权**
  >数制中某一位上的1所表示数值的大小（所处位置的价值）。例如，十进制的123，1的位权是100，2的位权是10，3的位权是1。二进制中的 1011 ，第一个1的位权是8，0的位权是4，第二个1的位权是2，第三个1的位权是1

  **常见的进制：**
  - 十进制
  - 二进制
  - 十六进制
  - 八进制
  #### 十进制：
  ⑴定义：以10位基数的计数体制简称十进制
  ⑵特点：
  ①系数：0、1、2、3、4、5、6、7、8、9
  
  ②计数规律：逢十进一，9+1=10
  
  ③权：基数的幂，即2的幂
  
  10的几次幂：右侧的第一位：10的0次幂=1  
        
             右侧的第二位：10的1次幂=10
     
             右侧的第三位：10的2次幂=100
  
 ![图片](https://hi-yee.github.io/coconut-blog/images/imageSoftwareTestingTheory/ct-02.png)

  **★现代计算机采用的是：冯诺依曼体系结构**
   #### 二进制：
   ⑴定义：以2位基数的计数体制简称十进制
   
   ⑵特点：

    ①系数：0、1

    ②计数规律：逢二进一，1+1=(10)2=(10)B（后缀B表示2进制）

    ③权：基数的幂，即10的幂

   2的几次幂：  右侧的第一位：2的0次幂=1
   
             右侧的第二位：2的1次幂=2
             
             右侧的第三位：2的2次幂=4
         
   ![图片](https://hi-yee.github.io/coconut-blog/images/imageSoftwareTestingTheory/ct-03.png)
    
   #### 十六进制：
   ⑴定义：以16位基数的计数体制简称十进制
   
   ⑵特点：

    ①系数：0、1、2、3、4、5、6、7、8、9、A、B、C、D、E、F

    ②计数规律：逢十六进一，F+1=(10)16=10H（后缀H表示16进制）

    ③权：基数的幂，即16的幂

   16的几次幂：  右侧的第一位：2的0次幂=1
   
             右侧的第二位：2的1次幂=2
             
             右侧的第三位：2的2次幂=4
  ![图片](https://hi-yee.github.io/coconut-blog/images/imageSoftwareTestingTheory/ct-04.png)
  ![图片](https://hi-yee.github.io/coconut-blog/images/imageSoftwareTestingTheory/ct-05.png) 
    
   #### 八进制：
   ⑴定义：以8位基数的计数体制简称十进制
   
   ⑵特点：

    ①系数：0、1、2、3、4、5、6、7、

    ②计数规律：逢八进一，7+1=(10)8=10O（后缀O表示8进制）

    ③权：基数的幂，即8的幂

   8的几次幂：  ③权：基数的幂，即8的幂
   
             右侧的第二位：8的1次幂=8
             
             右侧的第三位：8的2次幂=64
  ![图片](https://hi-yee.github.io/coconut-blog/images/imageSoftwareTestingTheory/ct-06.png)
  
  
  ### 进制转换：  
  任何进制都能转换成十进制
  
  方法：按权展开求和（用每一位的系数乘以本位的权，然后进行相加）
  
  ①、二进制——十进制
  ![图片](https://hi-yee.github.io/coconut-blog/images/imageSoftwareTestingTheory/ct-07.png)
  
  ②、十六进制——十进制
  ![图片](https://hi-yee.github.io/coconut-blog/images/imageSoftwareTestingTheory/ct-08.png)
  
  ③、八进制——十进制
  ![图片](https://hi-yee.github.io/coconut-blog/images/imageSoftwareTestingTheory/ct-09.png)
  
  ④、十进制——其他进制
  >方法：除基去余逆排法（例如：二进制基数为2）

  >求商和余数，再使用这个数，除于基数，求的新的商和余数，反复进行直到商为0.

  ![图片](https://hi-yee.github.io/coconut-blog/images/imageSoftwareTestingTheory/ct-10.png)

  ![图片](https://hi-yee.github.io/coconut-blog/images/imageSoftwareTestingTheory/ct-11.png)
  
  ⑤、二进制——十六进制
  理论：使用4位二进制数表示1位16进制数

  十进制、十六进制、二进制参照表
  
  ![图片](https://hi-yee.github.io/coconut-blog/images/imageSoftwareTestingTheory/ct-12.png)
  
  方法:从低位（右侧）起，每四为数分成一组，最高位不够4位补零，然后按照顺序写出对应的十六进制数。（4合一）
  
  ![图片](https://hi-yee.github.io/coconut-blog/images/imageSoftwareTestingTheory/ct-13.png)
  
  ⑦、二进制——八进制
  理论基础:使用三位数二进制数表示1位八进制

  十进制、八进制、二进制参照表
  
   ![图片](https://hi-yee.github.io/coconut-blog/images/imageSoftwareTestingTheory/ct-14.png)
   
   方法：从低位（右侧）起每一位3位数分成1组，最高位不够三位数补零，然后按顺序写出对应的八进制。（3合一）

   ![图片](https://hi-yee.github.io/coconut-blog/images/imageSoftwareTestingTheory/ct-15.png)
  
  ⑨、八进制——二进制
  方法:用3位数二进制表示一位八进制，去掉最高位零，然后按顺序排列二进制数（1分3）
  
  ![图片](https://hi-yee.github.io/coconut-blog/images/imageSoftwareTestingTheory/ct-16.png)
  
  
### 2、逻辑代数
  含义：逻辑代数是分析和设计逻辑电路的数学基础。
  
  逻辑代数是有英国科学家乔治.布尔（George. Boole）创立的，故称“布尔代数”
  ⑴、与运算
  
  ①逻辑与：只有当一件事的几个条件全部具备之后，这件事才发生。
  
  设：开关A、B不通——灯不亮
  
    开关A、B通——灯亮
    
  ②真是表：输入与输出的对应关系
  
   ![图片](https://hi-yee.github.io/coconut-blog/images/imageSoftwareTestingTheory/ct-17.png)
   
  总结：输入只要有0输出必有0；输入全是1输出才是1（有0出0，全1才出1）
  
  ③表达式： Y=A●B
  
           Y=AB
           
  ④运算规则：有0出0，全1才1
  
  列如：算A与B的与运算
  
   ![图片](https://hi-yee.github.io/coconut-blog/images/imageSoftwareTestingTheory/ct-18.png)
   
   补充：两个多位二进制，进行按位逻辑与运算
     
      右侧对齐，A与B对应的位分别进行与运算即可
      
      （前位不够当零处理，站位）
   
   ⑵、或运算
   
   ①逻辑或：当一件事的几个条件中只要有一个条件具备，这件事就会发生。
   
   设：开关A、B不通——灯不亮
   
   
    开关A、B通——灯亮
    
   ②真是表：输入与输出的对应关系
   ![图片](https://hi-yee.github.io/coconut-blog/images/imageSoftwareTestingTheory/ct-19.png)
   
  总结：输入只要有1输出必有1；输入全是0输出才是0（有1出1，全0才出0）

  ③表达式： Y=A+B
           
  ④运算规则：有1出1，全0才0
  
  列如：算A与B的或运算
  ![图片](https://hi-yee.github.io/coconut-blog/images/imageSoftwareTestingTheory/ct-20.png)
  补充：两个多位二进制，进行按位逻辑或运算
  
      右侧对齐，A与B对应的位分别进行或运算即可
      
      （前位不够当零处理，站位）
      
      
   ⑶、非运算
   
   ①逻辑非：一件事情的发生是以其相反的条件为依据的
   
   设：开关A通——灯不亮
   
    开关A不通——灯亮
  
  ②真是表：输入与输出的对应关系
    ![图片](https://hi-yee.github.io/coconut-blog/images/imageSoftwareTestingTheory/ct-21.png)
  总结：输入只要有0输出必有0；输入全是1输出才是1（有0出0，全1才出1）

  ③表达式： Y=—A（A非/A反） 
          
  ④运算规则：取反
  
  列如：算A的非运算
   ![图片](https://hi-yee.github.io/coconut-blog/images/imageSoftwareTestingTheory/ct-22.png) 

  **补充：多位二进制，进行按位取反 **  
  
## 第三章 软件缺陷和缺陷报告
  >- 测试人员的主要职责

  >- 编写缺陷报告

  >- 缺陷报告的处理流程

### 1、测试人员的主要工作职责
  >- ①编写测试计划
  >- ②编写测试用例
  >- ③执行测试，发现缺陷提交缺陷报告
  >- ④验证所发现的缺陷是否得到修改
  >- ⑤编写测试总结报告

### 2、编写缺陷报告
  当测试人员发现了一个缺陷，需要填写一份“缺陷报告”来纪录这个缺陷，
  并通过这个缺陷报告告知开发人员所发生的一个问题——测试人员和开发人员交流沟通的重要工具。
 
### 3、缺陷报告的组成
  >- ⑴、缺陷编号（Defect ID）：
  提交缺陷的顺序

  >- ⑵、缺陷标题（Summary）：
  简明扼要的描述一下缺陷

  >- ⑶、缺陷的发现者（Detected By）：
  测试人员自己

  >- ⑷、发现缺陷的日期（Detected on date）：
  区别：data数据   date日期
  一般是当天

  >- ⑸、缺陷所属的模块（subject）：
  在测试哪个模块是发现的bug（开发组可以据此决定由谁来修改bug）

  >- ⑹、发现缺陷的版本（Detected inrelease）：
  在测试哪个版本的时候发现的bug

  >- ⑺、指派给谁处理（Assigned to）：
  测试人员指派给开发经理

    **开发经理根据缺陷所在模块，需再次指派具体的开发人员。**

  >- ⑻、缺陷的状态（Status）：
  缺陷此时所处的处理阶段或处理情况

     >- ①、测试人员发现缺陷，提交缺陷报告，把缺陷报告状态设置为：New（新发现的bug）

     >- ②、开发经理验证新提交的bug，如果是bug，状态改成：open（打开的bug，开发已承认的bug），如果不是bug，把状态改为：rejected（拒绝的bug）——bug需要经过讨论

     >- ③、开发人员看到指派给自己的解决的bug，进行bug修复，修改完成后把缺陷状态改成fixed（已修复，可反测）

     >- ④、测试人员对修复的bug进行返测，返测成功，把状态改为closed（关闭的缺陷，归档的bug），如果返测不成功，把状态改为：reopen（重新打开的bug）（返测不成功）

    **说明：**
     - 以上的过程就是缺陷的标准处理流程
 
     - 一个缺陷的生命周期

  ⑼、缺陷的严重程度（Severity）
  Bug对软件影响有多大
  >- Urgent：造成系统死机、重启、崩溃的缺陷，影响整体
  >- Veryhigh：非常严重的缺陷
  >- High：严重的，大的缺陷
  >- Medium：中等程度的缺陷
  >- Low：小的缺陷

  **每一个等级到底包括哪些缺陷，最好专门的文档中详细进行说明，这样可以使开发人员和测试人员达成共识。**
  **Bug Level Definition（缺陷等级定义）**

  ⑽、缺陷的优先级★★★★★
  测试人员希望该缺陷程序员在什么时间内或在哪个版本中解决。
  >- Urgent：立刻修改（如果不改影响开发或测试的进度）
  >- Veryhigh：本版本修改
  >- High：下版本修改
  >- Medium：发布之前修改
  >-Low：允许在发布中存在的

  ⑾、缺陷描述（Description）★★★★★
  
  **把发现bug的步骤，使用的数据等记录下来，使程序员通过该描述就清楚所发生的事情。**

### 4、写缺陷报告时注意的问题？

  >- ⑴、一个报告只提交一个缺陷
  >- ⑵、缺陷描述清晰，准去易读，使用最少，必须的步骤，包装缺陷可以再现
  >- ⑶、对缺陷的严重性，优先级的划分准确
  >- ⑷、提交前一定认真审核，确保缺陷是否有效的，二不因为自己的不正当造成“假缺陷”
  >- ⑸、不要引起开发人员的重视而夸大缺陷
  >- ⑹、小的缺陷也要报告
  >- ⑺、及时报告缺陷
  >- ⑻、对不可重现的缺陷也要报告
  >- ⑼、不做任何评价

### 5、面试问题
  **⑴、缺陷的严重程度和优先级是不是成正比？**
  
  Eg：界面问题的严重程度一般比较低，但优先级可是最高的——立即修复
  其他重大功能个问题可能暂时解决不了，但是不影响软件其他功能的使用，这是优先级可能定义的比较低——在发布之前修复


  **⑵、缺陷的严重性和优先级确定好以后，还会改吗？**
  
  Eg：测试人员确定一个缺陷为立即修复——严重程度不能修改
  ——优先级可以修改

  **⑶、是不是所有已发现的缺陷都会被修复？**
  
  不影响用户使用的，后面再以补丁或软件升级的方式进行弥补
  
### 6、缺陷报告的用途
  >- ⑴、纪录bug
  >- ⑵、对缺陷进行分类
  >- ⑶、跟踪bug
  >- ⑷、对bug进行分析统计

### 7、如何识别bug
  >- ⑴、通过测试用例的预期结果判断——实际结果与预期结果不一致，就是bug
  >- ⑵、通过需求（通过缺陷的5点定义识别）
  >- ⑶、沟通（开发、需求、用户）
  >- ⑷、对bug进行分析统计

### 8、截图技巧
  >- ⑴、将要截图的页面显示出来，按下键盘“print Screen”打印屏幕，把当亲的界面当成图片，存在windows的剪贴板上
  >- ⑵、打开画图——开始——附件里面
  >- ⑶、Ctrl+V 黏贴
  >- ⑷、点击工具选定——新建一个文档——Ctrl+V 黏贴
  >- ⑸、Ctrl+all全选
  >- ⑹、到word里面黏贴

### 9、缺陷报告的处理流程
  测试人员            >-                 提交缺陷报告

  开发经理            >-               分配缺陷任务

  开发人员            >-              处理缺陷报告

  测试人员            >-                返测报告

  测试人员            >-              关闭缺陷报告

  **注释：返测报告通过才会关闭缺陷报告，不通过返回给开发人员重新处理缺陷报告**
  
## 第四章 使用等价类和边界值方法设计测试用例
  >- 测试用例的概念
  >- 使用等价类划分方法设计测试用例
  >- 使用边界值方法设计测试用例
### （一）测试用例的基本概念
  **基本概念：**
  
  > 执行之前的指导测试过程的文档，包括：用例编号、测试目的、用例描述、预期结果。
  
  **测试用例存在的意义：**
  >- 1、不知道是否全面的测试了所有内容
     
    -不知道所有功能点是否测试到了？
    -不清楚每个功能点是否测前面了？

  >- 2、存在大量的冗余测试，影响测试效率
   有些功能可能重复测试了多次

  >- 3、对新版本的重复测试很难实施
   每个版本测试的步骤、数据都不一样，随意性很强

  >- 4、测试的覆盖率无法衡量
   最后测试的好与不好不得而知

  **测试用例解决的问题：**
  测试用例主要是纪录了测试的过程、步骤、输入的数据、预期的结果等内容。
   它是在测试之前有测试人员编写的指导测试的重要文档。  
    
    解决了要测什么、怎么测和如何衡量的问题。

   **编写测试用例的参考相关文档：**
  >- 需求文档
 
  >- 开发文档

  >- 用户手册

  **★如果有软件的早期版本，尽快熟悉软件的使用**

  **★与相关的人员讨论**
  
### （二）写用例需要什么东西
  >- 1、相关文档（需要文档，用户手册，开发文档）
  >- 2、（对着）相应开发出的软件
  >- 3、与相关人员讨论

### （三）编写测试用例的方法
  #### 1、等价类划分法
   ⑴ 等价类划分与基本概念
  ① 应用场合
  只要有数据输入的地方就可以使用，从无线的数据中选取少数代表性的数据进行测试

  ② 核心概念
  - **有效等价类**
  
  - 对程序规则有意义，合理的输入数据集合，程序接收到有效等价类数据，可以正确执行、计算

  - **无效等价类**
  
  对程序规则没有意义，不合理的输入数据集合，程序接收到无效等价类数据，应该给出错误提示，或者根本不让用户输入
  
  >- ⑵ 使用等价类划分编写用例
  首先：先确定测试的对象
  对于初学者，先一个控件一个控件去测，在测一个控件的时候，保证其他空间不要出错。

  **案例一：**
  两位整数的计算，取值范围 { -99-99 }

  测试对象——第一个数文本框
  >- 1、根据需要划分等价类
  ** ①有效等价类**
  -99-99之间的整数
  **②无效等价类**
  - 非整数
  - <-99
  - >99

  >- 2、细化等价类
  - ①把第一步中不是特别细致的部分在详细划分 
  - ②有些情况不是根据显示需求，而是根据数据
  
  **存储方式的理解。**
  说明：
  - 数据在计算机中采用补码存储，而整数和负数的补码计算机公式不同，所以需要把正数和负数单独测。
  > Eg：把-99-99划分成

    -99-0   0-99
    
   - 非整数可以在进行细化：小数，字母，符号等。
    ![图片](https://hi-yee.github.io/coconut-blog/images/imageSoftwareTestingTheory/ct-23.png) 
    
  >- 3、建立等价类表（熟练后直接进行该步骤
     **有效等价类表**
     | 有效等价类  |
     | --- | --- |
     | 编号   |    数据要求 |
     | 1      |  -99-0 |
     | 2      |   0-99 |
     
     
   **无效等价类表**
     | 无效等价类  |
     | --- | --- |
     | 编号   |    数据要求 |
     | 1      |  <-99|
     | 2      |  >99 |
     | 3      |  小数 |
     | 4      |  字母 |
     | 5      |  汉字 |
     | 6      |  为空 |
     | 7      |  符号 |
     

  >- 4、编写用例
  从每个等价类中至少选取一个数据作为代表进行测试，即可。

    因为，穷举测试（把所有的数据都输一遍）是不现实的，但是不做穷举测试会存在风险，编写用例的方法，就是使用更合理的数据，在最少的测试成本的情况下，尽可能的降低风险。
    如果时间允许或者对某些数据有争议，可以把它作为用例。
  ![图片](https://hi-yee.github.io/coconut-blog/images/imageSoftwareTestingTheory/ct-24.png) 
  
  ![图片](https://hi-yee.github.io/coconut-blog/images/imageSoftwareTestingTheory/ct-25.png) 
  
  >- ⑶ 等价类划分的步骤
    >- ①划分等价类
   >- ②细化等价类
   >- ③建立等价类表
   >- ④编写测试用例
  >- ⑷补充的内容
   >- **①什么是字节？（1个字节=8位bit）**

   **位：**"位(bit)"是电子计算机中最小的数据单位。每一位的状态只能是0或1。
   
   **字节：**8个二进制位构成1个"字节(Byte)"，它是存储空间的基本计量单位。
   1个字节可以储存1个英文字母或者半个汉字，换句话说，1个汉字占据2个字节的存储空间。
   
   **字：**"字"由若干个字节构成，字的位数叫做字长，不同档次的机器有不同的字长。
   例如一台8位机，它的1个字就等于1个字节，字长为8位。如果是一台16位机，那么，
   它的1个字就由2个字节构成，字长为16位。字是计算机进行数据处理和运算的单位。
   >1KB=1024个字节bytes=210=1024
   >1MB=1024KB
   >1GB=1024MB
   >1TB=1024GB
   >1PB=1024TB
   >1EB=1024PB
   >1兆B=1024kb
   >1GB=1024兆B
 
   >- ②补码
   计算机当中正数是以补码表示的，一个正数的补码和其原码相同。（将一个数转换成二进制，前面添加0，加到补齐32位或者64位）

   对于负数，则存放补码的方法是：将该数的绝对值 二进制形式 按位取反 再加1
   Eg：求-11的补码分四步骤：
   >⒈ -11的绝对值是：11
   >⒉ 11的二进制形式为：1011
   >⒊按位取反0100
   >⒋再加1:0101

   >补齐32位：0000 0000 0000 0000 0000 0000 0000 1011
   >32位取反：1111 1111 1111 1111 1111 1111 1111 0100
   >32再加以：1111 1111 1111 1111 1111 1111 1111 0101

   32位存储方式的利弊：
  **利：**方便分配（一刀切-管理方便）
  **弊：**浪费空间
  
  #### 2、边界值法
  >- ⑴ 边界值基本概念
   - ① 应用场合
   只要有数据输入的地方就可以使用，有效无效数据的分界点，需要单独拿出来测试。
   
   **A、有数据范围的**
   - Eg：-99-99之间的合法整数

  **B、数据字符个数的要求**
  - Eg：姓名字符范围：1-20个字符

  **★★★ 边界值一般和等价类一起应用，找到有效无效数据的分界点（最大值和最小值）以及其两边的点，进行测试，形成一套完整的测试方案。**

  - ② 如何使用
  **说明**
  >边界值的数据，本质上可以分为有效无效的判断，单从测试技术角度来讲，需要单独拿出来测试（必要的冗余）
  
  >- ⑵ 测试用例的作用(好处)
     >- 防止遗漏：使软件测试的实施重点突出，目的明确，确保需求功能不被遗漏；
     >- 版本重复测试：快速正确的进行版本重复测试；
     >- 监督过程：可以准确，有效的评估测试的工作量；
     >- 评估结果：对产品进行评估，对测试完成的情况进行评价；
     >- 提高效率：避免盲目测试
     >- 缩短周期：版本更新和升级，只需修正少部分测试用例资源复用。

  >- ⑶ 写测试用例的注意点
  >- ① 在编写测试用例之前，还需要明确项目对测试用例的具体需求：
  - A、测试用例编写如何命名
  - B、测试用例中用到的附件命名规定，存放位置
  - C、测试用例应该提交到什么地方

  >- ② 测试用例是需要更新和维护的，是一个不断修改完善的过程；

  >- ③ 测试用例需要正式的评审；

  >- ④ 测试用例覆盖的程序决定测试的覆盖程度。

  >- ⑷ 对测试人员的要求

  >- ① 基本要求——在编写测试用例时，要求步骤描述清晰，准确，易读，预测结果明确。
  - A、如果有特殊的设置，预支条件等要明确写出；
  - B、如果有输入数据，一般要给输入数据取值；
  - C、如果有附件，要给出附件存放位置，名称。

   **★★★ 检验标准：**
   
   写完用例后，让别人照着自己写的用例去执行，测试，可以很顺畅的执行下来。

  >- ② 高标准要求
  测试用例编写有条，有理，逻辑性强
   - 可以按照功能点分类，操作顺序逻辑年写，不要一会测这里，一会测那里

   - 功能覆盖全面，深入，能够发现软件中更过缺陷

   **★★★ 检验标准：**
   
   能把软件中的缺编尽可能多的找出来，按照你的测试用例测试完成的软件，遗留的缺陷最少——要求测试人员最终达到的目标，是一个需要长期联系，积累的过程。

  >- ⑸ 用例的优化
  >- ① 对于不同的控件的有效等价类一有效边界值可以尽可能在一条用例中进行测试。不同控件的有效等价类及有效边界可以组合测试——减少用例数量。

  >- ② 在一条用例中，先一次只测试一个空间的无效等价类强

  > 无效等价类在开始的时候不能组合
  > 避免“屏蔽”现象的发生
  > 想测试一下（验证）软件处理极端数据的能力

  **★★★ **
  **“屏蔽”现象指的是：前面的控件的错误提示一出现，后面的错误现象就不出现了——最后仔适当考虑无效等价类的组合**

  **★★★** 
  **字符包括：字母、符号、数字（0-9）、汉字**
  
  >- ⑹ 等价类划分经验
  >- ①有效等价类一般可以直接在需求中找到
  >- ② 无效等价类
  > 如果是必填项（不能为空）——————为空
  > 不是重复的————————————重复
  > 数据有范围————————————超出范围
  > 又字符个数要求——————————超出范围
  > 填写项允许的格式（整数，小数，字符）
  > 针对小数，小数点后的位数要求
 
  **★★★ **
  **说明：**
  **每个控件的有效等价类和有效边界的数量，一遍不会完全相等，会造成编写用例的数据的冗余，（测过的数据再选一次货多次）**
  
  #### 3、因果图法
  >- ⑴ 因果图基本概念
① 应用场合
  在一个界面有多个控件，测试的时候要考虑控件的组合关系，不同的控件组合胡产生不同的输出结果。结果的组合，为了弄清楚输入组组合会产生什么样的输出组合，使用因果图法。

  >- ⑵ 因果图的核心要点
  - ①因——原因，输入条件
  - ②过——结果，输出结果
  
  使用图形的方式，来分析软件输入和输出的对应关系
  
  >- ⑶ 图形符号
  ##### - **①基本图形符号——表示输入和输出的对应关系**
  >- A、恒等★★★★★
    a     恒等        b
 >![图片](https://hi-yee.github.io/coconut-blog/images/imageSoftwareTestingTheory/ct-26.png) 
  - a是输入；b是输出
  **含义：若原因出现，则结果出现，若原因不出现，则结果也不出现**
      
       - 若 a=1，则 b=1
      
       - 若 a=0，则 b=0

  >- B、非（～）
  ![图片](https://hi-yee.github.io/coconut-blog/images/imageSoftwareTestingTheory/ct-27.png) 
   a     非        b

  - a是输入；b是输出
  ** 含义：若原因出现，则结果不出现，若原因不出现，则结果出现
      若 a=1，则 b=0
      若 a=0，则 b=0

  >- C、或（∨）
  ![图片](https://hi-yee.github.io/coconut-blog/images/imageSoftwareTestingTheory/ct-28.png) 
  - a是输入；b是输出
  ** 含义：若几个原因中有一个出现，则结果出现，若几个原因都不出现，则结果不出现
      若 a=1，或 b=1，或 C=1，则 d=1
      若 a=b=c=0，则 d=0

  >- D、与（∧）★★★★★
  ![图片](https://hi-yee.github.io/coconut-blog/images/imageSoftwareTestingTheory/ct-29.png) 

  - a是输入；b是输出
  ** 含义：若几个原因都出现，结果才出现，若其中有一个不出现，则结果不出现
      若 a=0，或 b=0，或 C=0，则 d=0
      若 a=b=c=1，则 d=1
  
  ##### - **② 约束（限制条件）图形**
  要不然单独限制输入，要不单独限制输出。不能一次既限制输入和输出。**
  
  >- A、互斥（E）
 
  ![图片](https://hi-yee.github.io/coconut-blog/images/imageSoftwareTestingTheory/ct-30.png) 
  - a，b，c是输入；d是输出
  ** 含义：a、b、c三个原因不会同时成立，最多有一个可能成立，a、b、c不能同时为1，即a、b、c中至少有一个为1
      
      

  >- B、包含（I） 
  ![图片](https://hi-yee.github.io/coconut-blog/images/imageSoftwareTestingTheory/ct-31.png) 

  - a，b，c是输入；d是输出
  ** 含义：a、b、c三个原因至少有一个必须成立，a、b、c不能同时为10，即a、b、c中至少有一个为1

  >- C、唯一（O）
  ![图片](https://hi-yee.github.io/coconut-blog/images/imageSoftwareTestingTheory/ct-32.png) 
  - a，b，c是输入；d是输出
  ** 含义：a、b、c三个必须有一个成立，有且仅有一个成立

  ** 说明：唯一的情况是有一个默认值，而互斥没有默认值。

  >- D、要求（R）
  ** 含义：表示当a出现时，b必须也出现
  **若a=1，则b=1，即不可能a=1且b=0

  >- E、屏蔽（M）

 ** 含义：a=1，则b必须为0，而当a为0时，b的值不一定

  
  #### 4、使用判定表法设计测试用例
  - Eg：交通一卡通自动系统充值模拟系统
  ![图片](https://hi-yee.github.io/coconut-blog/images/imageSoftwareTestingTheory/ct-33.png) 
  
  >- (1)步骤一：找出所有的原因编号（输入编号）
  - ①投币50元
  - ②投币100元
  - ③充值50元
  - ④充值100元
  - 能组合的：①+③、①+④、②+③、②+④
  - 不能组合的：①+②、③+④
  - 可以单独组合：①、②、③、④

  >- (2)步骤二：找出所有的结果编号（输出编号）
  - A、充值成功并退卡
  - B、提示充值成功
  - C、找零
  - D、提示错误
  - 必须一起的：A+B
  - 不能组合的：A+D、B+D
  - 能组合：A+B+C、C+D、D

  >- (3)步骤三：在步骤一的基础上找到输入的限制关系和组合关系——决定了测试用例的多少
  >- A、限制关系，（哪些不能组合仔一起（有制约关系））
  - 输入①+②——互斥
  - 输入③+④——互斥

  >- B、组合关系（决定测试用例的数量）
  - ⒈输入（1）和（3）组合
  - ⒉输入（1）和（4）组合
  - ⒊输入（2）和（3）组合
  - ⒋输入（4）和（3）组合
  - ⒌输入（1）单独
  - ⒍输入（2）单独
  - ⒎输入（3）单独
  - ⒏输入（4）单独

  >- (4)步骤四：在步骤二的基础上，找到输出的限制关系和组合关系

  - （1）限制关系
  - ①输入A+D不能（互斥）
  - ②输入B+D不能（互斥）

  - （2）组合关系
  - ①输出A和B必须组合
  - ②输出A、B、C组合
  - ③输出C和D组合
  - ④输出D单独

  - 步骤3、4是深入分析需求的过程

  >- (5)步骤五：找到输入组合和输出组合的对应关系（什么样的输入组合会产生什么样的输出组合）——一依据步骤三（2）和步骤4（2）

  >- 情况一： 
  - 输入（1）和（3）组合
  - 会产生：A和B必须组合
  >- 情况二：
  - 输入（1）和（4）组合
  - 会产生：C和D组合

  >-情况三：
  - 输入（2）和（3）组合
  - 会产生：A、B、C组合

  >- 情况四：
  - 输入（4）和（3）组合
  - 会产生：A和B必须组合

  >- 情况五：
  - 输入（1）单独
  - 会产生：C和D组合

  >- 情况六：
  - 输入（2）单独
  - 会产生：C和D组合

  >- 情况七：
  - 输入（3）单独
  - 会产生：D单独

  >- 情况八：
  - 输入（4）单独
  - 会产生：D单独
  
  ** 测试用例展示:
    ![图片](https://hi-yee.github.io/coconut-blog/images/imageSoftwareTestingTheory/ct-34.png) 
    
  ** ★★★因果图形符号总结：  
    ![图片](https://hi-yee.github.io/coconut-blog/images/imageSoftwareTestingTheory/ct-35.png)   
    ![图片](https://hi-yee.github.io/coconut-blog/images/imageSoftwareTestingTheory/ct-36.png)  
    
    
  #### 5、使用正交排列法设计测试用例
  #### 6、使用场景法设计测试用例
  #### 7、测试大纲法
  #### 8、状态转换图（比较复杂，工作比较少用，效率低，面试可能用到）
  #### 9、测试用例方法选择综合策略
  
  
## 第五章 软件测试基本理论
### 1、软件开发阶段划分
### 2、软件测试阶段划分
### 3、软件测试模型
### 4、软件测试的分类   


## 第六章 测试管理工具 Quality center
### 1、二级标题
### 2、二级标题
### 3、二级标题
### 4、二级标题
### 5、二级标题

## 第七章
### 1、二级标题
### 2、二级标题
### 3、二级标题
### 4、二级标题
### 5、二级标题

## 第八章
### 1、二级标题
### 2、二级标题
### 3、二级标题
### 4、二级标题
### 5、二级标题

## 第九章
### 1、二级标题
### 2、二级标题
### 3、二级标题
### 4、二级标题
### 5、二级标题

## 第十章
### 1、二级标题
### 2、二级标题
### 3、二级标题
### 4、二级标题
### 5、二级标题

## 第十一章
### 1、二级标题
### 2、二级标题
### 3、二级标题
### 4、二级标题
### 5、二级标题



